#include "pch/pch.hpp"

using namespace std;
using namespace arvore;

// Defini√ß√£o das vari√°veis globais dentro do namespace
namespace execucao {
  vector<ArvoreGenealogica*> arvoresGlobal;
  unordered_map<string, Pessoa*> pessoasGlobal;
}

// Implementa√ß√µes das fun√ß√µes dentro do namespace
namespace execucao {

  void limparTela() {
#ifdef _WIN32
    system("cls");
#else
    system("clear");
#endif
  }

  void pausar() {
    cout << "Pressione Enter para continuar...";
    cin.get();
  }

  Pessoa* criarPessoaInterface() {
    string nome, dataNascimento;
    char genero;

    cout << "=== CRIAR PESSOA ===" << endl;

    cout << "Nome completo: ";
    getline(cin, nome);

    if (nome.empty()) {
      cout << "‚ùå Erro: Nome n√£o pode ser vazio" << endl;
      return nullptr;
    }

    // Verificar se pessoa j√° existe
    if (pessoasGlobal.find(nome) != pessoasGlobal.end()) {
      cout << "‚ùå Erro: Pessoa com este nome j√° existe" << endl;
      return nullptr;
    }

    cout << "Data de nascimento (DD/MM/AAAA): ";
    getline(cin, dataNascimento);

    cout << "G√™nero (M/F): ";
    cin >> genero;
    cin.ignore();

    genero = toupper(genero);
    if (genero != 'M' && genero != 'F') {
      cout << "‚ùå Erro: G√™nero deve ser 'M' ou 'F'" << endl;
      return nullptr;
    }

    Pessoa* novaPessoa = criarPessoa(nome, dataNascimento, genero);
    pessoasGlobal[nome] = novaPessoa;

    // Adicionar pessoa a todas as √°rvores existentes
    for (auto& arvore : arvoresGlobal) {
      arvore->indicePessoas[nome] = novaPessoa;
    }

    cout << "‚úÖ Pessoa criada com sucesso!" << endl;
    cout << "Nome: " << novaPessoa->nome << endl;
    cout << "Data: " << novaPessoa->dataNascimento << endl;
    cout << "G√™nero: " << novaPessoa->genero << endl;

    return novaPessoa;
  }

  Familia* criarFamiliaInterface() {
    cout << "=== CRIAR FAM√çLIA ===" << endl;

    if (pessoasGlobal.empty()) {
      cout << "‚ùå Erro: Nenhuma pessoa cadastrada. Crie pessoas primeiro." << endl;
      return nullptr;
    }

    cout << "Pessoas cadastradas:" << endl;
    int index = 1;
    unordered_map<int, Pessoa*> indicePessoas;
    vector<Pessoa*> homens;
    vector<Pessoa*> mulheres;

    for (auto& par : pessoasGlobal) {
      Pessoa* p = par.second;
      cout << index << " - " << p->nome
        << " (" << p->genero << ")"
        << " - " << p->dataNascimento << endl;

      indicePessoas[index] = p;
      if (p->genero == 'M') homens.push_back(p);
      else mulheres.push_back(p);
      index++;
    }

    if (homens.empty() || mulheres.empty()) {
      cout << "‚ùå Erro: √â necess√°rio pelo menos 1 homem e 1 mulher para criar uma fam√≠lia" << endl;
      return nullptr;
    }

    int escolhaPai, escolhaMae;

    cout << endl << "Selecione o PAI (n√∫mero): ";
    cin >> escolhaPai;
    cin.ignore();

    if (indicePessoas.find(escolhaPai) == indicePessoas.end() ||
      indicePessoas[escolhaPai]->genero != 'M') {
      cout << "‚ùå Erro: Sele√ß√£o inv√°lida ou pessoa n√£o √© do g√™nero masculino" << endl;
      return nullptr;
    }
    Pessoa* pai = indicePessoas[escolhaPai];

    cout << "Selecione a M√ÉE (n√∫mero): ";
    cin >> escolhaMae;
    cin.ignore();

    if (indicePessoas.find(escolhaMae) == indicePessoas.end() ||
      indicePessoas[escolhaMae]->genero != 'F') {
      cout << "‚ùå Erro: Sele√ß√£o inv√°lida ou pessoa n√£o √© do g√™nero feminino" << endl;
      return nullptr;
    }
    Pessoa* mae = indicePessoas[escolhaMae];

    Familia* novaFamilia = criarFamilia(pai, mae);
    pai->familiaOrigem = novaFamilia;
    mae->familiaOrigem = novaFamilia;

    cout << "‚úÖ Fam√≠lia criada com sucesso!" << endl;
    cout << "Pai: " << pai->nome << endl;
    cout << "M√£e: " << mae->nome << endl;

    return novaFamilia;
  }

  void criarArvoreInterface() {
    cout << "=== CRIAR √ÅRVORE GENEAL√ìGICA ===" << endl;

    ArvoreGenealogica* novaArvore = criarArvore();

    // Adicionar pessoas existentes √† nova √°rvore
    for (auto& par : pessoasGlobal) {
      novaArvore->indicePessoas[par.first] = par.second;
    }

    arvoresGlobal.push_back(novaArvore);

    cout << "‚úÖ √Årvore geneal√≥gica criada com sucesso!" << endl;
    cout << "Total de √°rvores: " << arvoresGlobal.size() << endl;
    cout << "Pessoas na √°rvore: " << novaArvore->indicePessoas.size() << endl;
  }

  void listarPessoas() {
    cout << "=== PESSOAS CADASTRADAS ===" << endl;

    if (pessoasGlobal.empty()) {
      cout << "Nenhuma pessoa cadastrada." << endl;
      return;
    }

    for (auto& par : pessoasGlobal) {
      Pessoa* p = par.second;
      cout << "Nome: " << p->nome << endl;
      cout << "Data: " << p->dataNascimento << endl;
      cout << "G√™nero: " << p->genero << endl;
      cout << "Fam√≠lia: " << (p->familiaOrigem ? "Vinculada" : "N√£o vinculada") << endl;
      cout << "------------------------" << endl;
    }

    cout << "Total: " << pessoasGlobal.size() << " pessoas" << endl;
  }

  void salvarArquivoUnico() {
    cout << "=== SALVAR BANCO DE DADOS ===" << endl;

    if (persistencia::salvarBancoDeDados(arvoresGlobal, pessoasGlobal)) {
      cout << "‚úÖ Banco de dados salvo com sucesso em data/armazenamento.json" << endl;
      cout << "   √Årvores salvas: " << arvoresGlobal.size() << endl;
      cout << "   Pessoas salvas: " << pessoasGlobal.size() << endl;
    }
    else {
      cout << "‚ùå Falha ao salvar banco de dados" << endl;
    }
  }

  void carregarArquivoUnico() {
    cout << "=== CARREGAR BANCO DE DADOS ===" << endl;

    if (persistencia::carregarBancoDeDados(arvoresGlobal, pessoasGlobal)) {
      cout << "‚úÖ Banco de dados carregado com sucesso!" << endl;
      cout << "   √Årvores: " << arvoresGlobal.size() << endl;
      cout << "   Pessoas: " << pessoasGlobal.size() << endl;
    }
    else {
      cout << "‚ùå Nenhum banco de dados encontrado ou erro ao carregar" << endl;
    }
  }

  void salvarArvoreInterface() {
    cout << "=== SALVAR √ÅRVORE (Compatibilidade) ===" << endl;

    if (arvoresGlobal.empty()) {
      cout << "‚ùå Erro: Nenhuma √°rvore para salvar" << endl;
      return;
    }

    string nomeArquivo;
    cout << "Nome para salvar a √°rvore: ";
    getline(cin, nomeArquivo);

    if (nomeArquivo.empty()) {
      cout << "‚ùå Erro: Nome n√£o pode ser vazio" << endl;
      return;
    }

    // Usar a primeira √°rvore para compatibilidade
    if (persistencia::salvarArvore(arvoresGlobal[0], nomeArquivo)) {
      cout << "‚úÖ √Årvore salva com sucesso!" << endl;
    }
    else {
      cout << "‚ùå Falha ao salvar √°rvore" << endl;
    }
  }

  void carregarArvoreInterface() {
    cout << "=== CARREGAR √ÅRVORE (Compatibilidade) ===" << endl;

    vector<string> arvores = persistencia::listarArvoresSalvas();

    if (arvores.empty()) {
      cout << "Nenhuma √°rvore salva encontrada." << endl;
      return;
    }

    cout << "√Årvores dispon√≠veis:" << endl;
    for (size_t i = 0; i < arvores.size(); i++) {
      cout << i + 1 << " - " << arvores[i] << endl;
    }

    cout << "0 - Cancelar" << endl;
    cout << "Escolha uma √°rvore: ";

    int escolha;
    cin >> escolha;
    cin.ignore();

    if (escolha == 0) return;

    if (escolha < 1 || escolha > static_cast<int>(arvores.size())) {
      cout << "‚ùå Escolha inv√°lida" << endl;
      return;
    }

    string nomeArvore = arvores[escolha - 1];

    // Limpar √°rvores atuais
    for (auto arvore : arvoresGlobal) {
      delete arvore;
    }
    arvoresGlobal.clear();
    pessoasGlobal.clear();

    // Carregar nova √°rvore
    ArvoreGenealogica* arvoreCarregada = persistencia::carregarArvore(nomeArvore);

    if (arvoreCarregada) {
      arvoresGlobal.push_back(arvoreCarregada);

      // Popular pessoas globais a partir da √°rvore carregada
      for (const auto& par : arvoreCarregada->indicePessoas) {
        pessoasGlobal[par.first] = par.second;
      }
      cout << "‚úÖ √Årvore carregada com sucesso!" << endl;
    }
  }

  void listarArvoresSalvasInterface() {
    cout << "=== √ÅRVORES SALVAS ===" << endl;

    vector<string> arvores = persistencia::listarArvoresSalvas();

    if (arvores.empty()) {
      cout << "Nenhuma √°rvore salva encontrada." << endl;
      return;
    }

    cout << "√Årvores no banco de dados:" << endl;
    for (const auto& nome : arvores) {
      cout << "üìÅ " << nome << ".json" << endl;
    }
    cout << "Total: " << arvores.size() << " √°rvores" << endl;
  }

}